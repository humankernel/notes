# deadlock

> el bloqueo mutuo en un sistema ocurre cuando un grupo de procesos est치 en espera de un evento para proseguir su ejecuci칩n, solo que, en este caso, el evento nunca llegar치

![[Pasted image 20240218110845.webp|500]]


## OS resources

![[Pasted image 20240218111250.webp|500]]


**Recursos apropiables**:
	Se pueden tomar de los procesos que los poseen sin efectos da침inos

**Recursos no apropiables**
	No se pueden tomar de su poseedor activo sin provocar un fallo de c치lculo
	Los bloqueos estan asociados con estos

Ejemplo: un proceso comienza a imprimir una salida, se toma la impresora y se le otorga a otro proceso. El resultado ser치 una salida incomprensible. 
<u>Las impresoras no son apropiables</u>

## Conditions for deadlock

![[deadlock-conds.excalidraw|500]]


## Representation 

### Matrix 

**Matrix de asignacion (A)**:
$p (procesos) * r (recursos)$
$A[i, j]$: especifica cuantas unidades del recurso $j$ estan <u>asignadas</u> al proceso $i$
$$S = \begin{equation}
	\begin{bmatrix}
	& R_1 & R_2 & R_3 \\
	P_1 & 1 & 0 & 1 \\
	P_2 & 0 & 1 & 0 \\
	P_3 & 0 & 1 & 1 \\
	\end{bmatrix}
\end{equation}
$$


**Matrix de solicitud (S)**:
$p (procesos) * r (recursos)$
$S[i, j]$: especifica cuantas unidades del recurso $j$ estan <u>esperando</u> el proceso $i$ que se le concedan
$$S = \begin{equation}
	\begin{bmatrix}
	& R_1 & R_2 & R_3 \\
	P_1 & 1 & 0 & 1 \\
	P_2 & 0 & 1 & 0 \\
	P_3 & 0 & 1 & 1 \\
	\end{bmatrix}
\end{equation}
$$

**Vector de recursos existentes (E)**:
$r (recursos)$
$R[i]$: especifica cuantas unidades del recurso $i$ existen

$$E = \begin{equation}
	\begin{bmatrix}
	R_1 & R_2 & R_3 \\
	1 & 2 & 3
	\end{bmatrix}
\end{equation}
$$

**Vector de recursos disponibles (D)**:
$r (recursos)$
$$D = E - A$$



> [!caution] Restricciones:
> **Restricci칩n de asignaci칩n**:
> No puede haber asignado mas instancias de las que existen
> 	
> **Restricci칩n de solicitud**
> Lo que se tiene + lo que se pide <= lo que existe
> $洧냢[洧녰,멇롐듛 +멇롐[洧녰,멇롐듛 \le멇롏[洧녱]$



Es posible obtener una representaci칩n matricial a partir de una representaci칩n gr치fica:

![[Pasted image 20240218204930.webp|500]]


### Graph

2 nodos 
si la flecha va del nodo recurso al nodo proceso significa que esta asignado el recurso
Al reves es que esta solicitado 

![[file-g6Hv64uO.webp|300]]


![[file-0SjfJeiC.webp|300]]



En esta situacion <u>no ocurre interbloqueo</u> a pesar que hay un ciclo, debido a que hay 2 instancias del recurso2 de liberarse el proceso3 que lo usa se ejecuta el proceso 2 termina y se ejecuta el proceso 1
![[Pasted image 20240218193858.webp]]





## How to solve a deadlock?

1. Ignorar el problema.
2. Detecci칩n y recuperaci칩n.
3. Evitarlos din치micamente mediante una cuidadosa asignaci칩n de recursos.
4. Prevenci칩n mediante la negaci칩n estructural de una de las cuatro condiciones necesarias.

### Ignore the problem

![[Pasted image 20240225131306.webp|500]]

Depende de los objetivos del sistema operativo.
- De prop칩sito general: pesa m치s la comodidad.
- Tiempo real: pesa m치s la correcci칩n.

### Detect & Recover

**Detecci칩n**

Con esta t칠cnica el sistema, intenta detectar cu치ndo ocurre un bloqueo y despu칠s lleva a cabo una acci칩n para recuperarse. 

쮼n qu칠 momento ejecutar el algoritmo de detecci칩n?
- Transcurrido un rango o intervalo de tiempo prudente.
- Cuando el rendimiento del sistema cae por debajo de cierto umbral. Ej.: 40% uso CPU.

**Detecci칩n para una instancia por recurso**

Buscar ciclos (interbloqueos) del grafo

![[Pasted image 20240225131332.webp]]

El siguiente algoritmo inspecciona la gr치fica y termina cuando encuentra un ciclo o sabe que no hay ninguno. Utiliza una estructura de datos, L, una lista de nodos y durante el algoritmo, los arcos se marcan para indicar que ya han sido visitados:

1. Para cada nodo N de la gr치fica, se desarrollan los siguientes cinco pasos, con N como nodo inicial.
2. Se inicializa L como una lista vac칤a y todos los arcos como no marcados.
3. Se a침ade el nodo activo al final de L y se verifica si el nodo aparece en L dos veces. Si lo hace, la gr치fica contiene un ciclo (que se enlista en L) y el algoritmo termina.
4. Desde el nodo dado, se verifica si existen arcos que salgan de 칠l y no est칠n marcados. En caso afirmativo, se pasa al paso 5; en otro caso al paso 6.
5. Se elige al azar un arco de salida no marcado y se le marca. Despu칠s se sigue este arco hasta el nuevo nodo activo y se regresa al paso 3.
6. Hemos llegado a un punto donde no podemos continuar. Se regresa al nodo anterior; es decir, aquel que estaba activo antes de este; se le se침ala de nuevo como nodo activo y se pasa al paso n칰mero 3. Si este nodo era el nodo inicial, la gr치fica no contiene ciclos y el algoritmo termina.

**Detecci칩n para varias instancias por recurso**

Consiste en simular la ejecuci칩n de los procesos con los recursos disponibles, si es posible hasta que terminen, marc치ndolos y agregando los recursos que pose칤an al grupo de disponible del sistema. Si todos se marcan no hay bloqueo, si no los procesos que no se pueden marcar con los recursos asignados y solicitados est치n bloqueados. 

Algoritmo:
1. Se busca un proceso no marcado Pi, para que el i-칠simo rengl칩n de S sea menor que D.
2. Si se encuentra el proceso, se suma el i-칠simo rengl칩n de A a D, se marca el proceso y se regresa al paso 1.
3. Si no existe tal proceso el algoritmo termina.

Al concluir el algoritmo, los procesos no marcados, de existir alguno, est치n bloqueados.



### Dinamicaly avoid 

Asignar los recursos de forma que nunca ocurra un interbloqueo

