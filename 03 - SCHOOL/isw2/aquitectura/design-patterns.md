
### Tarea

| Patrones GRASP         | Problema                                                                                                                                               | Solución                                                                                                                  | Ejemplo práctico                                                                                                                                                                                                                               |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Polimorfismo           | Necesidad de manejar objetos de diferentes tipos con un comportamiento común.                                                                          | Permitir que los objetos se comporten de acuerdo a su tipo, proporcionando una interfaz común para interactuar con ellos. | En un sistema de facturación, puedes tener diferentes tipos de productos (libros, ropa, electrónicos). Todos estos pueden tener un método `calcularImpuesto()`, pero la implementación puede variar según el tipo de producto.                 |
| Indirección            | Un componente necesita realizar una acción, pero no debería tener conocimiento directo del componente que realiza la acción.                           | Introducir un intermediario para desacoplar los componentos y promover la modularidad.                                    | En un sistema MVC, el controlador actúa como un intermediario entre la vista y el modelo. La vista no interactúa directamente con el modelo.                                                                                                   |
| No hables con extraños | Un objeto necesita solicitar una operación que involucra a otros objetos, pero no debería tener conocimiento de la estructura interna de esos objetos. | Un objeto sólo debería enviar mensajes a objetos que conoce directamente (asociaciones directas).                         | En un sistema de comercio electrónico, un objeto `Pedido` podría tener un método `total()`. Este método debería delegar el cálculo del total a los objetos `LineaPedido`, en lugar de navegar a través de `LineaPedido -> Producto -> Precio`. |
| Fábrica Pura           | Se necesita crear un objeto, pero el proceso de creación es complejo y debería estar encapsulado para promover la modularidad.                         | Introducir un método o clase dedicada para la creación de objetos.                                                        | En un sistema de videojuegos, podrías tener una clase `EnemigoFactory` que crea objetos `Enemigo` basados en parámetros como la dificultad del juego, la ubicación del jugador, etc.                                                           |

**Polimorfismo** ¿Quién es el responsable cuando el comportamiento varía en función del tipo? Cuando las alternativas o comportamientos relacionados varían según el tipo (clase), asigne la responsabilidad del comportamiento —utilizando operaciones polimórficas— a los tipos para los que varía el comportamiento

**Indirección** ¿Cómo asignar responsabilidades para evitar el acoplamiento directo? Asigne la responsabilidad a un objeto intermedio para mediar entre otros componentes o servicios, de manera que no se acoplan directamente.

**Fabricación Pura** ¿Quién es el responsable cuando está desesperado, y no quiere violar los principios de alta cohesión y bajo acoplamiento? Asigne un conjunto altamente cohesivo de responsabilidades a una clase de “comportamiento” artificial o de conveniencia que no representa un concepto del dominio del problema —algo inventado—, para dar soporte a la alta cohesión, bajo acoplamiento y la reutilización.

**Fabricacion Pura**: En otras palabras, este principio sugiere la creación de clases adicionales que no necesariamente representan una entidad del mundo real, pero que ayudan a mantener la organización y estructura del código, facilitando su mantenimiento y evolución.